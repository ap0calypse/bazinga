#!/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use Env qw(HOME USERNAME);
use v5.10;

# project:      bazinga
# description:  free special blogging tool, inspired by nanoblogger
# author:       Manuel Fill (ap0calypse@agitatio.org)
# license:      


# version info, config locations, ...
my $VERSION = "0.1a";
my $CONFIG = "$HOME/.bazinga/bazinga.conf";


# param check, we die if there is the wrong count
die "not enough parameters given, try 'bzg help' for a quick overview.\n" if scalar @ARGV < 1;
die "configuration file $CONFIG doesn't exist or isn't readable, please check.\n" unless (-e $CONFIG);


# arg-list processing
if ($ARGV[0]) {
    if ($ARGV[0] eq "help") {
        print_usage() and exit 0;
    }
    elsif ($ARGV[0] eq "add") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                print "parsing file $ARGV[1] ... ";
                process_content($ARGV[1]);
                print "DONE!\n";
            }
            else {
                print "$ARGV[1] is not a file, please specify a path to a valid content file.\n"; 
            }
        }
        else {
            print "You have to specify the path to a valid content file.\n";
            exit 2;
        }
    }
    elsif ($ARGV[0] eq "delete") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                print "deleting content $ARGV[1] from structure ... ";
                delete_content($ARGV[1]);
                print " DONE!\n";
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify a valid content id.\n";
            exit 3;
        }
    }
    elsif ($ARGV[0] eq "replace") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                if ($ARGV[2]) {
                    if (-e $ARGV[2]) {
                        print "replacing content $ARGV[1] with $ARGV[2] ... ";
#                        check_article($ARGV[1]);
                        print " DONE!\n";
                    }
                    else { 
                        print "$ARGV[1] is not a file, please specify a path to the content file.\n";
                    }
                }
                else {
                    print "You have to specify a valid content file\n";
                    exit 4;
                }
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify the id you want to be replaced.\n";
            exit 5;
        }
    }
    elsif ($ARGV[0] eq "check") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                print "checking article file $ARGV[1] for correctness ... ";
#                check_article($ARGV[1]);
                print "DONE!\n";
            }
            else { 
                print "$ARGV[1] is not a file, please specify a path to the article or comment file.\n"; 
            }
        }
        else {
            print "You have to specify the path to the content file which should be checked.\n";
            exit 6;
        }
    }
    elsif ($ARGV[0] eq "update") {
        if ($ARGV[1]) {
            if ($ARGV[1] eq "LOCAL") {
                print "updating local bazinga structure ... ";
#                update_bazinga($ARGV[1]);
                print "DONE!\n";
            }
            elsif ($ARGV[1] eq "REMOTE") {
                print "updating remote bazinga structure ... ";
#                update_bazinga($ARGV[1]);
                print "DONE!\n";
            }
            else { 
                print "$ARGV[1] is not a valid identifier. Needs to be LOCAL or REMOTE.\n"; 
            }
        }
        else {
            print "You have to specify the structure that should be updated.\n";
            exit 7;
        }
    }
    else { 
        print "You entered an unknown parameter, please check.\n"; 
    }
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: print_usage
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays short usage information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub print_usage {
    print qq(
    bazinga $VERSION

    quick overview:
    
        bzg help
        bzg add FILE
        bzg delete ID
        bzg replace ID FILE
        bzg check FILE
        bzg update LOCAL | REMOTE

    examples:

        bzg add my_fancy_new_article.txt
        bzg add about_me_page.txt
        bzg add comment_from_some_dude.txt
        bzg replace 6783423 corrected_article.txt
        bzg check maybe_corrupt_article.txt
        bzg update LOCAL
        bzg update REMOTE

);
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: process_content
# needs:    path to content file
# returns:  nothing
# calls:    add_content
# purpose:  processes the content file and fills a hash with the content information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub process_content {
    my $content_file = shift;
    my %cont_hash;
    open my $CONTFD ,"< $content_file" or die "File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        $cont_hash{'type'} = $1 and next if m/^type: *\"(article|comment|page){1}\".*$/;
        $cont_hash{$1} = $2 and next if m/^(.+): *\"(.+)\".*$/;
        if (/START_TEXT/ .. /END_TEXT/) {
            $cont_hash{'text'} .= $_ if $_ !~ /.*(END_TEXT|START_TEXT){1}.*/ ;
        }
    }
    close $CONTFD;
# here we need to add some error correction in case there is something missing in %art_hash ...
    add_content(\%cont_hash);
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: add_content
# needs:    reference to the content-hash
# returns:  nothing
# calls:    generate_html
# purpose:  processes the content hash and writes out the html-document to blog structure / index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub add_content {
    my $cont_hash_ref = shift;
    print "Adding content '" . $cont_hash_ref->{'title'} . "' to bazinga structure ...\n";
    
    my $random = join ("", ('a' .. 'f', 0 .. 9)[map {rand (16)} (1 .. 16)] );
    print "generated ID: $random\n";
    my $output = generate_html($cont_hash_ref);
    open my $OUTFD, "> ./blog/$random.html" or die "$!";
    print $OUTFD $output;
    close $OUTFD;

    open my $INDEXFD, ">> ./blog/index" or die "$!";
    print $INDEXFD "$random:$cont_hash_ref->{'tags'}:$cont_hash_ref->{'title'}:$cont_hash_ref->{'date'}\n";
    close $INDEXFD;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_html
# needs:    reference to content hash
# returns:  html-ified version of the text
# calls:    nothing
# purpose:  translates the content jargon to clean html
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_html {
    my $ref = shift;
    $ref->{'text'} =~ s/\n/<br \/>\n/g;
    $ref->{'text'} =~ s/CODE_START/<div class=\'code\'>/g;
    $ref->{'text'} =~ s/CODE_END/<\/div>/g;
    $ref->{'text'} =~ s/\/((\s|\w)+)\//<i>$1<\/i>/g;
    $ref->{'text'} =~ s/\*((\s|\w)+)\*/<b>$1<\/b>/g;
    $ref->{'text'} =~ s/_((\s|\w)+)_/<u>$1<\/u>/g;
    my $generated = <<"EOHTML";
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>$ref->{'title'}</title>
</head>
<body>
<h1>$ref->{'title'}</h1>
$ref->{'text'}
</body>
</html>
EOHTML
    return $generated;

}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: delete content
# needs:    valid id from a page / article / comment
# returns:  nothing
# calls:    nothing
# purpose:  deletes any content and the corresponding id from the index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub delete_content {
    my $id = shift;
    my $temp;
    open my $INDEXFD, "< ./blog/index" or die "$!";
    while (<$INDEXFD>) {
        if (s/^$id.+$//gmx) {
            chomp;
        }
        $temp .= $_;
    }
    unlink "./blog/$id.html";
    close $INDEXFD;
    open my $INDEXWR, "> ./blog/index" or die "$!";
    print $INDEXWR $temp;
    close $INDEXWR;
    
}





sub replace_content {}
sub check_content {}
sub update_bazinga {}
