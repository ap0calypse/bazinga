#!/usr/bin/perl
use strict;
use warnings;
use File::Copy;
use Storable;
use Env qw(HOME USERNAME);
use v5.10;

# project:      bazinga
# description:  free special blogging tool, inspired by nanoblogger
# author:       Manuel Fill (ap0calypse@agitatio.org)
# license:      GPL 

################################################################################
# version info, config locations, ...
################################################################################

my $VERSION = "0.1";
my $CONFIG = "$HOME/.bazinga/bazinga.conf";
my $CSS = "$HOME/.bazinga/style.css";
my $BZG_FILE = "$HOME/.bazinga/bazinga.dat";
my $TMP_LOCATION = "$HOME/.bazinga/temp";
my $TEMPLATEFILE = "$HOME/.bazinga/index.template";
my %CONF_HASH;
my %TAG_HASH;

################################################################################
# %needed_params are the paramaters that should be given in the content files
################################################################################

my %needed_params = (
    'articles'   => [qw(author title email website text date time tags)],
    'pages'      => [qw(author title email website text date time)],
);


################################################################################
# BZG_HASH is the mega-hash containing all the information.
# if the file is too small (<5b) we can surely asume it doesn't exist,
# otherwise we read in the hash from the file
################################################################################

my $BZG_HASH;
if (-e $BZG_FILE && (stat $BZG_FILE)[7] > 5) {
    $BZG_HASH = retrieve $BZG_FILE;
}

################################################################################
# here we parse the config file in the users home directory and fill %CONF_HASH
# with all the information.
################################################################################

open my $CONFFD, "< $CONFIG" or die "can't access config, please check $CONFIG\n";
while (<$CONFFD>) {
    next if m/^#.*/;
    next if m/^[[:space:]]+$/;
    if (m/.*BLOG_DIRECTORY: *\"(.+)\".*/) {
        $CONF_HASH{'blog_directory'} = $1;
        mkdir $CONF_HASH{'blog_directory'} unless -e $CONF_HASH{'blog_directory'};
        mkdir "$CONF_HASH{'blog_directory'}/pages" unless -e "$CONF_HASH{'blog_directory'}/pages";
        mkdir "$CONF_HASH{'blog_directory'}/articles" unless -e "$CONF_HASH{'blog_directory'}/articles";
        mkdir "$CONF_HASH{'blog_directory'}/css" unless -e "$CONF_HASH{'blog_directory'}/css";
    }
    if (m/.*BLOG_TITLE: *\"(.+)\".*/) {
        $CONF_HASH{'blog_title'} = $1;
    }
    if (m/.*BLOG_SUBTITLE: *\"(.+)\".*/) {
        $CONF_HASH{'blog_subtitle'} = $1;
    }
    if (m/.*BLOG_OWNER: *\"(.+)\".*/) {
        $CONF_HASH{'blog_owner'} = $1;
    }
    if (m/.*BLOG_EMAIL: *\"(.+)\".*/) {
        $CONF_HASH{'blog_email'} = $1;
    }
    if (m/.*BLOG_WEBSITE: *\"(.+)\".*/) {
        $CONF_HASH{'blog_website'} = $1;
    }
    if (m/.*LATEX_FGCOLOR: *\"(.+)\".*/) {
        $CONF_HASH{'latex_fgcolor'} = $1;
    }
    if (m/.*LATEX_BGCOLOR: *\"(.+)\".*/) {
        $CONF_HASH{'latex_bgcolor'} = $1;
    }
    if (m/.*LATEX_DPI: *\"(.+)\".*/) {
        $CONF_HASH{'latex_dpi'} = $1;
    }
}
close $CONFFD;


################################################################################
# param check, we die if there is the wrong count
################################################################################

die "not enough parameters given, try 'bzg help' for a quick overview.\n" if scalar @ARGV < 1;
die "configuration file $CONFIG doesn't exist or isn't readable, please check.\n" unless (-e $CONFIG);
mkdir $TMP_LOCATION unless -d $TMP_LOCATION;


################################################################################
# arg-list processing
################################################################################

if ($ARGV[0]) {
    if ($ARGV[0] eq "help") {
        print_usage() and exit 0;
    }
    elsif ($ARGV[0] eq "list") {
        list_contents() and exit 0;
    }
    elsif ($ARGV[0] eq "generate") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/(page|article){1}/) {
                make_template($1);
            }
            else {
                print "second argument must be 'article' or 'page'.\n";
            }
        }
    }
    elsif ($ARGV[0] eq "add") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(1, $ARGV[1]);
            }
            else {
                print "$ARGV[1] is not a file, please specify a path to a valid content file.\n"; 
            }
        }
        else {
            print "You have to specify the path to a valid content file.\n";
            exit 2;
        }
    }
    elsif ($ARGV[0] eq "delete") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                delete_content($ARGV[1]);
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify a valid content id.\n";
            exit 3;
        }
    }
    elsif ($ARGV[0] eq "replace") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                if ($ARGV[2]) {
                    if (-e $ARGV[2]) {
                        replace_content($ARGV[1], $ARGV[2]);
                    }
                    else { 
                        print "$ARGV[2] is not a file, please specify a path to the content file.\n";
                    }
                }
                else {
                    print "You have to specify a valid content file\n";
                    exit 4;
                }
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify the id you want to be replaced.\n";
            exit 5;
        }
    }
    elsif ($ARGV[0] eq "check") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(0, $ARGV[1]);
            }
            else { 
                print "$ARGV[1] is not a file, please specify a path to the article or comment file.\n"; 
            }
        }
        else {
            print "You have to specify the path to the content file which should be checked.\n";
            exit 6;
        }
    }
    elsif ($ARGV[0] eq "update") {
        update_bazinga();
    }
    elsif ($ARGV[0] eq "tag") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                if ($ARGV[2]) {
                    tag_article($ARGV[1], $ARGV[2]);
                }
                else { 
                   print "Please specify one or more tags.\n";
                   exit 4;
                }
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify the id you want to be re-tagged.\n";
            exit 5;
        }
    }
    else { 
        print "You entered an unknown parameter, please check.\n"; 
    }
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: print_usage
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays short usage information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub print_usage {
    print qq(
    bazinga $VERSION

    quick overview:
    
        bzg help
        bzg generate (article | page)
        bzg add FILE
        bzg delete ID
        bzg replace ID FILE
        bzg tag ID "TAG1 TAG2 TAG3 ..."
        bzg check FILE
        bzg list
        bzg update 

    examples:

        bzg generate article > my_template_article.txt
        bzg generate page > my_template_page.txt
        bzg add my_fancy_new_article.txt
        bzg add about_me_page.txt
        bzg replace 6783423 corrected_article.txt
        bzg tag 6783423 "main programming testing"
        bzg check maybe_corrupt_article.txt
        bzg update

);
}




# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: list_contents
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays a list of all the contents
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub list_contents {
    print "Articles:\n" . "* " x 20 . "\n\n";
    for (keys %{$BZG_HASH->{'articles'}}) {
        print " $_ ($BZG_HASH->{'articles'}{$_}{'title'})";
        print " from: $BZG_HASH->{'articles'}{$_}{'author'} - $BZG_HASH->{'articles'}{$_}{'date'}";
        print " $BZG_HASH->{'articles'}{$_}{'time'}\n";
    }
    print "\n\n";
    print "Pages:\n" . "* " x 20 . "\n";
    for (keys %{$BZG_HASH->{'pages'}}) {
        print " $_ ($BZG_HASH->{'pages'}{$_}{'title'})";
        print " from: $BZG_HASH->{'pages'}{$_}{'author'} - $BZG_HASH->{'pages'}{$_}{'date'}";
        print " $BZG_HASH->{'pages'}{$_}{'time'}\n";
    }
    print "\n\n";
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: add_content
# needs:    1 or 0 (only check), path to content file, (maybe ID, only if called from replace_content)
# returns:  nothing
# calls:    nothing
# purpose:  processes the content file and fills the super hash with the content information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub add_content {
    my $add = shift;
    my $content_file = shift;
    my $given_id = shift;
    my ($type, $random);
    if ($given_id) {
        $random = $given_id;
    }
    else {
        $random = join ("", ('a' .. 'f', 0 .. 9)[map {rand (16)} (1 .. 16)] );
    }
    open my $CONTFD ,"< $content_file" or die "File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        $BZG_HASH->{$1}{$random} = {} and $type = $1 and last if m/^category: *\"(articles|pages){1}\".*$/;
    }
    close $CONTFD;
    unless ($type) {
        print "Content file is missing the 'category' param, please check and re-run.\n";
        exit;
    }
    open $CONTFD ,"< $content_file" or die "File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        if (/START_TEXT/ .. /END_TEXT/) {
            $BZG_HASH->{$type}{$random}{'text'} .= $_ if $_ !~ /.*(END_TEXT|START_TEXT){1}.*/ ;
        }
        else {
            $BZG_HASH->{$type}{$random}{$1} = $2 and next if m/^(.+): *\"(.+)\".*$/;
        }

    }
    close $CONTFD;
    my $correct = 1;
    for my $list_item (@{$needed_params{$type}}) {
        unless ( grep {/$list_item/} keys %{$BZG_HASH->{$type}{$random}}) {
            print "argument '$list_item' is missing in content-file, exiting.\n";
            $correct = 0;
        }
    }
    if ($correct) {
        print "content file seems to be correct.\n";
    }
    else {
        print "content file is corrupt, please check.\n";
        exit;
    }
    if ($add) {
        store $BZG_HASH, $BZG_FILE;
        print "added '$random' to $type.\n";
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: delete content
# needs:    valid id from a page / article
# returns:  nothing
# calls:    nothing
# purpose:  deletes any content and the corresponding id from the index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub delete_content {
    my $delete_id = shift;
    my $key;
    if (exists $BZG_HASH->{'pages'}) {
        for $key (keys %{$BZG_HASH->{'pages'}}) {
            if ($key eq $delete_id) {
                delete $BZG_HASH->{'pages'}{$key};
                print "deleted page '$key'\n";
            }
        }
    }
    if (exists $BZG_HASH->{'articles'}) {
        for $key (keys %{$BZG_HASH->{'articles'}}) {
            if ($key eq $delete_id) {
                delete $BZG_HASH->{'articles'}{$key};
                print "deleted article '$key'\n";
            }
        }
    }
    store $BZG_HASH, $BZG_FILE;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: tag_article
# needs:    valid id from an article, string with tags
# returns:  nothing
# calls:    nothing
# purpose:  deletes the tags from a given article and adds new ones
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub tag_article {
    my ($tag_id, $tags) = @_;
    if (exists  $BZG_HASH->{'articles'}{$tag_id}) {
        $BZG_HASH->{'articles'}{$tag_id}{'tags'} = $tags;
        print "re-tagged article '$tag_id'.\n";
        store $BZG_HASH, $BZG_FILE;
    }
    else {
        print "article $tag_id  doesn't exist, please check.\n";
        exit 5;
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: replace_content
# needs:    valid id from a page / article, and path to a new content file
# returns:  nothing
# calls:    add_content, delete_content
# purpose:  deletes any content and the corresponding id from the index and adds a new one
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub replace_content {
    my ($id, $path) = @_;
    delete_content($id);
    add_content(1, $path, $id);
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: update_bazinga
# needs:    nothing
# returns:  nothing
# calls:    generate_file, generate_index
# purpose:  copies an existing css file from the users home dir to the structure or dies if the
#           copy-prrocess fails. after that it loops through the sections and then through the ids
#           and passes them to generate_file for further processing. in the end, the index is
#           (re)generated.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub update_bazinga {
    system("rm -rf " . $CONF_HASH{'blog_directory'} . "/*");
    generate_tagpages();
    if (-e $CSS) {
        mkdir($CONF_HASH{'blog_directory'} . "/css");
        copy($CSS, "$CONF_HASH{'blog_directory'}/css/style.css") or die "copy of css failed: $!\n";
    }
    for my $section (keys %{$BZG_HASH}) {
        for (keys %{$BZG_HASH->{$section}}) { 
            generate_file($section, $_);
        }
    }
    generate_index();
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_file
# needs:    category (articles/pages/tags) and the ID (which could be a tagname too)
# returns:  nothing
# calls:    convert_text
# purpose:  uses the index-template to generate a website for an article or a page. additionally,
#           it creates the needed directory-structure. tag-pages were added after initial 
#           implementation, but fit in here quite nicely. :)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_file {
    my ($type, $id) = @_;
    mkdir ($CONF_HASH{'blog_directory'} . "/$type");
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$id");
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$id/img") unless $type eq "tags";
    my $indexfile = $CONF_HASH{'blog_directory'} . "/$type/$id/index.html";
    open my $INDEX, "> $indexfile" or die "$!";
    open my $TEMPLATE, "< $TEMPLATEFILE" or die "$!";
    while (my $line = <$TEMPLATE>) {
        if ($line =~ m/\[BLOG_TITLE\]/gmx) {
            $line =~ s/\[BLOG_TITLE\]/$CONF_HASH{'blog_title'}/gmx;
        }
        if ($line =~ m/\[BLOG_SUBTITLE\]/gmx) {
            $line =~ s/\[BLOG_SUBTITLE\]/$CONF_HASH{'blog_subtitle'}/gmx;
        }
        if ($line =~ m/\[STYLESHEET_LOCATION\]/gmx) {
            $line =~ s/\[STYLESHEET_LOCATION\]/\.\.\/\.\.\/css\/style.css/gmx;
        }
        if ($line =~ m/\[MENU\]/gmx) {
            $line =~ s/\[MENU\]//gmx;
            $line .= "<div class='menupoint'><a href='../../index.html'>" .
                     "main page</a></div><br />\n";
            for (sort keys %{$BZG_HASH}) {
                $line .= "<div class='menupoint'>$_</div>\n";
                if ($_ eq 'articles') {
                    $line .= "<ul>\n";
                    for my $tags (sort keys %TAG_HASH) {
                        $line .= "<li><a href='../../tags/$tags/index.html'>" .
                                 $tags . "</a><div style='float: right;'>( " . scalar @{$TAG_HASH{$tags}} . 
                                 " )</div></li>\n";
                    }
                    $line .= "</ul>\n";
                }
                elsif ($_ eq 'pages') {
                    $line .= "<ul>\n";
                    for my $pageid (sort {$BZG_HASH->{'pages'}{$a}{'title'} cmp $BZG_HASH->{'pages'}{$b}{'title'}} 
                                        keys %{$BZG_HASH->{'pages'}}) {

                        $line .= "<li><a href='../../pages/$pageid/index.html'>" . 
                                 $BZG_HASH->{'pages'}{$pageid}{'title'} . "</a></li>\n";
                    
                    }
                    $line .= "</ul>\n";
                }
            }
        }
        if ($line =~ m/\[CONTENT\]/gmx) {
            if ($type ne "tags") {
                $line =~ s/\[CONTENT\]//gmx;
                $line .= "<h2>$BZG_HASH->{$type}{$id}{'title'}</h2>";
                $line .= convert_text($BZG_HASH->{$type}{$id}{'text'}, $id);
            }
            else {
                $line =~ s/\[CONTENT\]//gmx;
                $line .= "<h2>Articles with tag: $id</h2>";
                for (@{$TAG_HASH{$id}}) {
                    $line .= "<p>(" . $BZG_HASH->{'articles'}{$_}{'date'} . 
                             " - " . $BZG_HASH->{'articles'}{$_}{'time'} . 
                             ") : <a href='../../articles/$_/index.html'>" . 
                             $BZG_HASH->{'articles'}{$_}{'title'} .
                             "</a></p>";
                }
            }
            if ($type eq 'articles') {
            $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{$type}{$id}{'author'} . 
                     " in " . join(", ", split / /, $BZG_HASH->{$type}{$id}{'tags'}) . " on <i>" .
                     $BZG_HASH->{$type}{$id}{'date'} . " " . $BZG_HASH->{$type}{$id}{'time'} .
                     "</i></div>";
            }
            elsif ($type eq 'pages') {
            $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{$type}{$id}{'author'} . 
                     " on <i>" .
                     $BZG_HASH->{$type}{$id}{'date'} . " " . $BZG_HASH->{$type}{$id}{'time'} .
                     "</i></div>";
            }
        }

        print $INDEX $line;
    }
    close $INDEX;
    close $TEMPLATE;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_index
# needs:    nothing
# returns:  nothing
# calls:    convert_text
# purpose:  uses the index-template to generate the main index page.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_index {
    my $indexfile = $CONF_HASH{'blog_directory'} . "/index.html";
    open my $INDEX, "> $indexfile" or die "$!";
    open my $TEMPLATE, "< $TEMPLATEFILE" or die "$!";
    my %date_hash;
    while (my $line = <$TEMPLATE>) {
        if ($line =~ m/\[BLOG_TITLE\]/gmx) {
            $line =~ s/\[BLOG_TITLE\]/$CONF_HASH{'blog_title'}/gmx;
        }
        if ($line =~ m/\[BLOG_SUBTITLE\]/gmx) {
            $line =~ s/\[BLOG_SUBTITLE\]/$CONF_HASH{'blog_subtitle'}/gmx;
        }
        if ($line =~ m/\[STYLESHEET_LOCATION\]/gmx) {
            $line =~ s/\[STYLESHEET_LOCATION\]/\.\/css\/style.css/gmx;
        }
        if ($line =~ m/\[MENU\]/gmx) {
            $line =~ s/\[MENU\]//gmx;
            $line .= "<div class='menupoint'><a href='./index.html'>" .
                     "main page</a></div><br />\n";
            for (sort keys %{$BZG_HASH}) {
                $line .= "<div class='menupoint'>$_</div>\n";
                if ($_ eq 'articles') {
                    $line .= "<ul>\n";
                    for my $tags (sort keys %TAG_HASH) {
                        $line .= "<li><a href='./tags/$tags/index.html'>" .
                                 $tags . "</a><div style='float: right;'>( " . scalar @{$TAG_HASH{$tags}} . 
                                 " )</div></li>\n";
                    }
                    $line .= "</ul>\n";
                }
                elsif ($_ eq 'pages') {
                    $line .= "<ul>\n";
                    for my $pageid (sort {$BZG_HASH->{'pages'}{$a}{'title'} cmp $BZG_HASH->{'pages'}{$b}{'title'}} 
                                        keys %{$BZG_HASH->{'pages'}}) {

                        $line .= "<li><a href='./pages/$pageid/index.html'>" . 
                                 $BZG_HASH->{'pages'}{$pageid}{'title'} . "</a></li>\n";
                    
                    }
                    $line .= "</ul>\n";
                }
            }
        }
        if ($line =~ m/\[CONTENT\]/gmx) {
            $line =~ s/\[CONTENT\]//gmx;
            for (keys %{$BZG_HASH->{'articles'}}) {
                push @{$date_hash{$BZG_HASH->{'articles'}{$_}{'date'} . " " . $BZG_HASH->{'articles'}{$_}{'time'}}}, $_;
            }
            for (reverse sort keys %date_hash) {
                for my $id (@{$date_hash{$_}}) {
                    $line .= "<h2><a href='./articles/$id/index.html'>$BZG_HASH->{'articles'}{$id}{'title'}</a></h2>";
                    $line .= convert_text($BZG_HASH->{'articles'}{$id}{'text'}, $id, "index");
                    $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{'articles'}{$id}{'author'} . 
                             " in " . join(", ", split / /, $BZG_HASH->{'articles'}{$id}{'tags'}) . " on <i>" .
                             $BZG_HASH->{'articles'}{$id}{'date'} . " " . $BZG_HASH->{'articles'}{$id}{'time'} .
                             "</i></div>";
                }
            }
        }

        print $INDEX $line;
    }
    close $INDEX;
    close $TEMPLATE;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_tagpages
# needs:    nothing
# returns:  nothing
# calls:    generate_file
# purpose:  goes through the content-hash and generates the corresponding pages
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_tagpages {
    for my $artid (keys %{$BZG_HASH->{'articles'}}) {
        for (split / /, $BZG_HASH->{'articles'}{$artid}{'tags'}) {
            push @{$TAG_HASH{$_}}, $artid;
        }
    }
    system("rm -rf " .  $CONF_HASH{'blog_directory'} . "/tags/ 2> /dev/null");
    for (keys %TAG_HASH) {
        mkdir $CONF_HASH{'blog_directory'} . "/tags/" 
        unless -d $CONF_HASH{'blog_directory'} . "/tags/";
        mkdir $CONF_HASH{'blog_directory'} . "/tags/$_" 
        unless -d $CONF_HASH{'blog_directory'} . "/tags/$_";
        generate_file("tags", $_);
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: convert_text
# needs:    scalar textstring from generate_file, article-id, ("index")
# returns:  processed scalar textstring
# calls:    systemcalls: texi2dvi, dvipng
# purpose:  converts the string between START_TEXT and END_TEXT from the content file into desired
#           format. converts latex-formulae into pictures, hihjlights the code, and so on.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub convert_text {
    my $text = shift;
    my $art_id = shift;
    my $is_index = shift;
    my ($code_text, $code_lang, $want_ln, $line_number, $in_code, $in_latex, $in_gnuplot, $latex_present, $gnuplot_present) = 
       (0, 0, 0, 0, 0, 0, 0, 0, 0);
    $text =~ s/\r//gmx;
    my ($LATEXFD, $GNUPLOTFD, $IMAGEFD);
    my @textlines = split /\n/, $text;
    my $finaltext;
    for (@textlines) {
        if (m/LATEX_START/) {
            $latex_present++;
            $in_latex = 1;
            open $LATEXFD, "> $TMP_LOCATION/$latex_present.tex";
            print $LATEXFD "\\documentclass{article}\n" .  "\\pagestyle{empty}\n" . "\\begin{document}\n";
            if ($is_index) {
                $finaltext .= "<br /><img src='./articles/$art_id/img/$latex_present-latex.png' alt='$latex_present' /><br />\n";
            }
            else {
                $finaltext .= "<br /><img src='./img/$latex_present-latex.png' alt='$latex_present' /><br />\n";
            }
            next;
        }
        if (m/LATEX_END/) {
            $in_latex = 0;
            print $LATEXFD "\n\\end{document}\n";
            close $LATEXFD;
            next;
        }
        if (m/GNUPLOT_START/) {
            $gnuplot_present++;
            $in_gnuplot = 1;
            open $GNUPLOTFD, "> $TMP_LOCATION/$gnuplot_present.plot";
            print $GNUPLOTFD "set terminal png\n" . "set output '$gnuplot_present-plot.png'\n";
            if ($is_index) {
                $finaltext .= "<br /><img src='./articles/$art_id/img/$gnuplot_present-plot.png' alt='$gnuplot_present' /><br />\n";
            }
            else {
                $finaltext .= "<br /><img src='./img/$gnuplot_present-plot.png' alt='$gnuplot_present' /><br />\n";
            }
            next;
        }
        if (m/GNUPLOT_END/) {
            $in_gnuplot = 0;
            close $GNUPLOTFD;
            next;
        }
        if (m/CODE_START=([[:alnum:]]+)=?(ln|LN)?/) {
            ($in_code, $line_number) = (1, 1);
            $code_lang = lc $1;
            if (defined $2 and $2 =~ m/ln|LN/) {
                $want_ln = 1;
            }
            else {
                $want_ln = 0;
            }
            $finaltext .= "<pre class='sourcecode'>\n";
            next;
        }
        if (m/CODE_END/) {
            $in_code = 0;
            $finaltext .= "</pre>\n";
            next;
        }

        if ($in_latex) {
            print $LATEXFD $_ . "\n";
        }
        elsif ($in_code) {
            $finaltext .= `echo '$_' | highlight -s 'vampire' -I -f -l -m $line_number --inline-css -S perl` if $want_ln;
            $finaltext .= `echo '$_' | highlight -s 'vampire' -I -f --inline-css -S perl` unless $want_ln;
            $line_number++;
        }
        elsif ($in_gnuplot) {
            print $GNUPLOTFD $_ . "\n";
        }
        else {
            $finaltext .= $_;
        }
    }
    for (1 .. $latex_present) {
        mkdir "$CONF_HASH{'blog_directory'}/articles/$art_id";
        mkdir "$CONF_HASH{'blog_directory'}/articles/$art_id/img";
        system("cd $TMP_LOCATION; texi2dvi -q $_.tex");
        system("cd $TMP_LOCATION; dvipng -q $TMP_LOCATION/$_.dvi -bg \'$CONF_HASH{'latex_bgcolor'}\' -D $CONF_HASH{'latex_dpi'} " .
               "-fg \'$CONF_HASH{'latex_fgcolor'}\' -O .1in -T tight " .
               "-o $CONF_HASH{'blog_directory'}/articles/$art_id/img/$_-latex.png ");
        unlink("$TMP_LOCATION/$_.tex", "$TMP_LOCATION/$_.aux", "$TMP_LOCATION/$_.dvi", "$TMP_LOCATION/$_.log");
    }
    for (1 .. $gnuplot_present) {
        mkdir "$CONF_HASH{'blog_directory'}/articles/$art_id";
        mkdir "$CONF_HASH{'blog_directory'}/articles/$art_id/img";
        system("cd $TMP_LOCATION; gnuplot $TMP_LOCATION/$_.plot");
        system("convert -scale 400x300 $TMP_LOCATION/$_-plot.png $CONF_HASH{'blog_directory'}/articles/$art_id/img/$_-plot.png");
        unlink("$TMP_LOCATION/$_.plot", "$TMP_LOCATION/$_-plot.png");
    }

    return $finaltext;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: make_template 
# needs:    category (article/comment/page)
# returns:  doesn't return anything, but prints a template content file to STDOUT
# calls:    nothing
# purpose:  creates a template for an article, comment or page which the user can then pipe into 
#           a file and change the values to his needs.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub make_template {
    my $type = shift;
    $type = "articles" if $type eq "article";
    $type = "pages" if $type eq "page";
    my $date = sprintf("%d-%02d-%02d", (localtime)[5] + 1900, (localtime)[4] + 1, (localtime)[3]);
    my $time = sprintf("%02d:%02d", (localtime)[2], (localtime)[1]);
    $CONF_HASH{'blog_owner'} = $USERNAME unless $CONF_HASH{'blog_owner'};
    if ($type eq 'articles') {
        print <<"EOTEMP";
category: "$type"
title: ""
author: "$CONF_HASH{"blog_owner"}"
website: "$CONF_HASH{"blog_website"}"
email: "$CONF_HASH{"blog_email"}"
date: "$date"
time: "$time"
tags: ""
START_TEXT

END_TEXT

EOTEMP
    }
    elsif ($type eq "pages") {
        print <<"EOTEMP";
category: "$type"
title: ""
author: "$CONF_HASH{"blog_owner"}"
website: "$CONF_HASH{"blog_website"}"
email: "$CONF_HASH{"blog_email"}"
date: "$date"
time: "$time"
START_TEXT

END_TEXT

EOTEMP
    }
}
