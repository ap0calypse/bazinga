#!/usr/bin/perl
use strict;
use warnings;
use CGI qw/:standard/;
use Data::Dumper;
use Storable;
use Env qw(HOME USERNAME);
use v5.10;

# project:      bazinga
# description:  free special blogging tool, inspired by nanoblogger
# author:       Manuel Fill (ap0calypse@agitatio.org)
# license:      


################################################################################
# version info, config locations, ...
################################################################################

my $VERSION = "0.1a";
my $CONFIG = "$HOME/.bazinga/bazinga.conf";
my $CSS = "$HOME/.bazinga/style.css";
my %CONF_HASH;
my $BZG_FILE = "$HOME/.bazinga/bazinga.dat";


################################################################################
# %needed_params are the paramaters that should be given in the content files
################################################################################

my %needed_params = (
    'article'   => [qw(author title email website text date time tags)],
    'page'      => [qw(author title email website text date time)],
    'comment'   => [qw(author email website text date time to_article)],
);


################################################################################
# BZG_HASH is the mega-hash containing all the information.
# if the file is too small (<5b) we can surely asume it doesn't exist,
# otherwise we read in the hash from the file
################################################################################

my $BZG_HASH;
if (-e $BZG_FILE && (stat $BZG_FILE)[7] > 5) {
    $BZG_HASH = retrieve $BZG_FILE;
}


################################################################################
# here we parse the config file in the users home directory and fill %CONF_HASH
# with all the information.
################################################################################

open my $CONFFD, "< $CONFIG" or die "can't access config, please check $CONFIG\n";
while (<$CONFFD>) {
    next if m/^#.*/;
    next if m/^[[:space:]]+$/;
    if (m/.*BLOG_DIRECTORY: *\"(.+)\".*/) {
        $CONF_HASH{'blog_directory'} = $1;
        print "Your config doesn't contain a valid 'BLOG_DIRECTORY'\n" and exit unless $CONF_HASH{'blog_directory'};
        mkdir $CONF_HASH{'blog_directory'} unless -e $CONF_HASH{'blog_directory'};
        mkdir "$CONF_HASH{'blog_directory'}/page" unless -e "$CONF_HASH{'blog_directory'}/page";
        mkdir "$CONF_HASH{'blog_directory'}/article" unless -e "$CONF_HASH{'blog_directory'}/article";
        mkdir "$CONF_HASH{'blog_directory'}/comment" unless -e "$CONF_HASH{'blog_directory'}/comment";
    }
}
close $CONFFD;


################################################################################
# param check, we die if there is the wrong count
################################################################################

die "not enough parameters given, try 'bzg help' for a quick overview.\n" if scalar @ARGV < 1;
die "configuration file $CONFIG doesn't exist or isn't readable, please check.\n" unless (-e $CONFIG);


################################################################################
# arg-list processing
################################################################################

if ($ARGV[0]) {
    if ($ARGV[0] eq "help") {
        print_usage() and exit 0;
    }
    elsif ($ARGV[0] eq "list") {
        list_contents() and exit 0;
    }
    elsif ($ARGV[0] eq "add") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(1, $ARGV[1]);
            }
            else {
                print "$ARGV[1] is not a file, please specify a path to a valid content file.\n"; 
            }
        }
        else {
            print "You have to specify the path to a valid content file.\n";
            exit 2;
        }
    }
    elsif ($ARGV[0] eq "delete") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                delete_content($ARGV[1]);
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify a valid content id.\n";
            exit 3;
        }
    }
    elsif ($ARGV[0] eq "replace") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                if ($ARGV[2]) {
                    if (-e $ARGV[2]) {
                        replace_content($ARGV[1], $ARGV[2]);
                    }
                    else { 
                        print "$ARGV[1] is not a file, please specify a path to the content file.\n";
                    }
                }
                else {
                    print "You have to specify a valid content file\n";
                    exit 4;
                }
            }
            else { 
                print "$ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print "You have to specify the id you want to be replaced.\n";
            exit 5;
        }
    }
    elsif ($ARGV[0] eq "check") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(0, $ARGV[1]);
            }
            else { 
                print "$ARGV[1] is not a file, please specify a path to the article or comment file.\n"; 
            }
        }
        else {
            print "You have to specify the path to the content file which should be checked.\n";
            exit 6;
        }
    }
    elsif ($ARGV[0] eq "update") {
        update_bazinga();
    }
    else { 
        print "You entered an unknown parameter, please check.\n"; 
    }
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: print_usage
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays short usage information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub print_usage {
    print qq(
    bazinga $VERSION

    quick overview:
    
        bzg help
        bzg add FILE
        bzg delete ID
        bzg replace ID FILE
        bzg check FILE
        bzg list
        bzg update 

    examples:

        bzg add my_fancy_new_article.txt
        bzg add about_me_page.txt
        bzg add comment_from_some_dude.txt
        bzg replace 6783423 corrected_article.txt
        bzg check maybe_corrupt_article.txt
        bzg update

);
}




# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: list_contents
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays a list of all the contents
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub list_contents {
    print "Articles:\n" . "* " x 20 . "\n\n";
    for (keys %{$BZG_HASH->{'article'}}) {
        print " $_ ($BZG_HASH->{'article'}{$_}{'title'})";
        print " from: $BZG_HASH->{'article'}{$_}{'author'} - $BZG_HASH->{'article'}{$_}{'date'}";
        print " $BZG_HASH->{'article'}{$_}{'time'}\n";
    }
    print "\n\n";
    print "Pages:\n" . "* " x 20 . "\n";
    for (keys %{$BZG_HASH->{'page'}}) {
        print " $_ ($BZG_HASH->{'page'}{$_}{'title'})";
        print " from: $BZG_HASH->{'page'}{$_}{'author'} - $BZG_HASH->{'page'}{$_}{'date'}";
        print " $BZG_HASH->{'page'}{$_}{'time'}\n";
    }
    print "\n\n";
    print "Comments:\n" . "* " x 20 . "\n";
    for (keys %{$BZG_HASH->{'comment'}}) {
        print " $_ (-> $BZG_HASH->{'comment'}{$_}{'to_article'})";
        print " from: $BZG_HASH->{'comment'}{$_}{'author'} - $BZG_HASH->{'comment'}{$_}{'date'}";
        print " $BZG_HASH->{'comment'}{$_}{'time'}\n";
    }
    print "\n\n";
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: add_content
# needs:    1 or 0 (only check), path to content file, (maybe ID, only if called from replace_content
# returns:  nothing
# calls:    nothing
# purpose:  processes the content file and fills the super hash with the content information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub add_content {
    my $add = shift;
    my $content_file = shift;
    my $given_id = shift;
    my ($type, $random);
    if ($given_id) {
        $random = $given_id;
    }
    else {
        $random = join ("", ('a' .. 'f', 0 .. 9)[map {rand (16)} (1 .. 16)] );
    }
    open my $CONTFD ,"< $content_file" or die "File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        $BZG_HASH->{$1}{$random} = {} and $type = $1 and last if m/^type: *\"(article|comment|page){1}\".*$/;
    }
    close $CONTFD;
    unless ($type) {
        print "Content file is missing the 'type' param, please check and re-run.\n";
        exit;
    }
    open $CONTFD ,"< $content_file" or die "File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        $BZG_HASH->{$type}{$random}{$1} = $2 and next if m/^(.+): *\"(.+)\".*$/;
        if (/START_TEXT/ .. /END_TEXT/) {
            $BZG_HASH->{$type}{$random}{'text'} .= $_ if $_ !~ /.*(END_TEXT|START_TEXT){1}.*/ ;
        }
    }
    close $CONTFD;
    my $correct = 1;
    for my $list_item (@{$needed_params{$type}}) {
        unless ( grep {/$list_item/} keys %{$BZG_HASH->{$type}{$random}}) {
            print "argument '$list_item' is missing in content-file, exiting.\n";
            $correct = 0;
        }
    }
    if ($correct) {
        print "content file seems to be correct.\n";
    }
    else {
        print "content file is corrupt, please check.\n";
        exit;
    }
    if ($add) {
        store $BZG_HASH, $BZG_FILE;
        print "added article '$random'\n";
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: delete content
# needs:    valid id from a page / article / comment
# returns:  nothing
# calls:    nothing
# purpose:  deletes any content and the corresponding id from the index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub delete_content {
    my $delete_id = shift;
    my $key;
    if (exists $BZG_HASH->{'page'}) {
        for $key (keys %{$BZG_HASH->{'page'}}) {
            if ($key eq $delete_id) {
                delete $BZG_HASH->{'page'}{$key};
                print "deleted page '$key'\n";
            }
        }
    }
    elsif (exists $BZG_HASH->{'article'}) {
        for $key (keys %{$BZG_HASH->{'article'}}) {
            if ($key eq $delete_id) {
                delete $BZG_HASH->{'article'}{$key};
                print "deleted article '$key'\n";
            }
        }
    }
    elsif (exists $BZG_HASH->{'comment'}) {
        for $key (keys %{$BZG_HASH->{'comment'}}) {
            if ($key eq $delete_id) {
                delete $BZG_HASH->{'comment'}{$key};
                print "deleted comment '$key'\n";
            }
        }
    }
    else {
        print "Your structure seems to be empty ... exiting\n";
    }
    store $BZG_HASH, $BZG_FILE;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: replace_content
# needs:    valid id from a page / article / comment, and path to a new content file
# returns:  nothing
# calls:    add_content, delete_content
# purpose:  deletes any content and the corresponding id from the index and adds a new one
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub replace_content {
    my ($id, $path) = @_;
    delete_content($id);
    add_content(1, $path, $id);
}
sub update_bazinga {
    for my $section (keys %{$BZG_HASH}) {
    print "searching through section '$section' ...\n";
        for (keys %{$BZG_HASH->{$section}}) { 
            print $_, "\n";
            generate_file($section, $_);
        }
    }
    generate_index();
}

sub generate_file {
    my ($type, $id) = @_;
}

sub generate_index {}
