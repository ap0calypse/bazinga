#!/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use Env qw(HOME USERNAME);
use v5.10;

# project:      bazinga
# description:  free special blogging tool, inspired by nanoblogger
# author:       Manuel Fill (ap0calypse@agitatio.org)
# license:      


# version info, config locations, ...
my $VERSION = "0.1a";
my $CONFIG = "$HOME/.bazinga/bazinga.conf";


# param check, we die if there is the wrong count
die "not enough parameters given, try 'bzg help' for a quick overview.\n" if scalar @ARGV < 1;
die "configuration file $CONFIG doesn't exist or isn't readable, please check.\n" unless (-e $CONFIG);


# arg-list processing
given ($ARGV[0]) {
    when (/help?/) {
        print_usage() and exit 0;
    }
    when (/add?/) {
        given ($ARGV[1]) {
            when ($ARGV[1] ne "" && -e $ARGV[1]) {
                print "parsing file $ARGV[1] ... ";
                process_article($ARGV[1]);
                print "DONE!\n";
            }
            default { print "$ARGV[1] is not a file, please specify a path to the article or comment file.\n"; }
        }
    }
    when (/delete?/) {
        given ($ARGV[1]) {
            when ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                print "deleting article $ARGV[1] from articles ... ";
                delete_article($ARGV[1]);
                print " DONE!\n";
            }
            default { print "$ARGV[1] is not a valid id, please specify a correct id.\n"; }
        }
    }
    when (/replace?/) {
        given ($ARGV[1]) {
            when ($ARGV[1] =~ m/[[:alnum:]]{16}/) {
                given ($ARGV[2]) {
                    when (-e $ARGV[2]) {
                        print "replacing article $ARGV[1] with $ARGV[2] ... ";
#                        check_article($ARGV[1]);
                        print " DONE!\n";
                    }
                    default { print "$ARGV[1] is not a file, please specify a path to the article file.\n"; }
                }
            }
            default { print "$ARGV[1] is not a valid id, please specify a correct id.\n"; }
        }
    }
    when (/check?/) {
        given ($ARGV[1]) {
            when (-e $ARGV[1]) {
                print "checking article file $ARGV[1] for correctness ... ";
#                check_article($ARGV[1]);
                print "DONE!\n";
            }
            default { print "$ARGV[1] is not a file, please specify a path to the article or comment file.\n"; }
        }
    }
    when (/update?/) {
        given ($ARGV[1]) {
            when (/LOCAL?/) {
                print "updating local bazinga structure ... ";
#                update_bazinga($ARGV[1]);
                print "DONE!\n";
            }
            when (/REMOTE?/) {
                print "updating remote bazinga structure ... ";
#                update_bazinga($ARGV[1]);
                print "DONE!\n";
            }
            default { print "$ARGV[1] is not a valid identifier. Needs to be LOCAL or REMOTE.\n"; }
        }
    }
    default { print "You entered an unknown parameter, please check.\n"; }
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: print_usage
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays short usage information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub print_usage {
    print qq(
    bazinga $VERSION

    quick overview:
    
        bzg help
        bzg add FILE
        bzg delete ID
        bzg replace ID FILE
        bzg check FILE
        bzg update LOCAL | REMOTE

    examples:

        bzg add my_fancy_new_article.txt
        bzg add comment_from_some_dude.txt
        bzg replace 6783423 corrected_article.txt
        bzg check maybe_corrupt_article.txt
        bzg update LOCAL
        bzg update REMOTE

);
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: process_article
# needs:    path to article file
# returns:  nothing
# calls:    add_article
# purpose:  processes the article file and fills a hash with the article information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub process_article {
    my $article_file = shift;
    my %art_hash;
    open my $ARTFD ,"< $article_file" or die "File could not be opened, please check permissions.\n";
    while (<$ARTFD>) {
        $art_hash{'type'} = $1 and next if m/^type: *\"(article|comment){1}\".*$/;
        $art_hash{$1} = $2 and next if m/^(.+): *\"(.+)\".*$/;
        if (/START_TEXT/ .. /END_TEXT/) {
            $art_hash{'text'} .= $_ if $_ !~ /.*(END_TEXT|START_TEXT){1}.*/ ;
        }
    }
    close $ARTFD;
# here we need to add some error correction in case there is something missing in %art_hash ...
    add_article(\%art_hash);
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: add_article
# needs:    reference to the article-hash
# returns:  nothing
# calls:    generate_html
# purpose:  processes the article hash and writes out the html-document to blog structure / index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub add_article {
    my $art_hash_ref = shift;
    print "Adding article '" . $art_hash_ref->{'title'} . "' to bazinga structure ...\n";
    
    my $random = join ("", ('a' .. 'f', 0 .. 9)[map {rand (16)} (1 .. 16)] );
    print "generated ID: $random\n";
    my $output = generate_html($art_hash_ref);
    open my $OUTFD, "> ./blog/$random.html" or die "$!";
    print $OUTFD $output;
    close $OUTFD;

    open my $INDEXFD, ">> ./blog/index" or die "$!";
    print $INDEXFD "$random:$art_hash_ref->{'tags'}:$art_hash_ref->{'title'}\n";
    close $INDEXFD;
}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_html
# needs:    reference to article hash
# returns:  html-ified version of the text
# calls:    nothing
# purpose:  translates the article jargon to clean html
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_html {
    my $ref = shift;
    $ref->{'text'} =~ s/\n/<br \/>\n/g;
    $ref->{'text'} =~ s/CODE_START/<div class=\'code\'>/g;
    $ref->{'text'} =~ s/CODE_END/<\/div>/g;
    $ref->{'text'} =~ s/\/((\s|\w)+)\//<i>$1<\/i>/g;
    $ref->{'text'} =~ s/\*((\s|\w)+)\*/<b>$1<\/b>/g;
    $ref->{'text'} =~ s/_((\s|\w)+)_/<u>$1<\/u>/g;
    my $generated = <<"EOHTML";
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>$ref->{'title'}</title>
</head>
<body>
<h1>$ref->{'title'}</h1>
$ref->{'text'}
</body>
</html>
EOHTML
    return $generated;

}





# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: delete article
# needs:    valid id from an article
# returns:  nothing
# calls:    nothing
# purpose:  deletes an article and the corresponding id from the index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub delete_article {
    my $id = shift;
    my $temp;
    open my $INDEXFD, "< ./blog/index" or die "$!";
    while (<$INDEXFD>) {
        if (s/^$id.+$//gmx) {
            chomp;
        }
        $temp .= $_;
    }
    unlink "./blog/$id.html";
    close $INDEXFD;
    open my $INDEXWR, "> ./blog/index" or die "$!";
    print $INDEXWR $temp;
    close $INDEXWR;
    
}





sub replace_article {}
sub check_article {}
sub update_bazinga {}
