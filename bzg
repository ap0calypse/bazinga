#!/usr/bin/perl
use strict;
use warnings;
use File::Copy;
use Storable;
use Env qw(HOME USERNAME);
use v5.10;

# project:      bazinga
# date:         2011-09 - dato
# description:  free special blogging tool, inspired by nanoblogger
# author:       see AUTHORS
# license:      see LICENSE 


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# version info, config locations, ...
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

my $VERSION = "0.3.5";
my $BAZDIR = "$HOME/.bazinga";
my $CONFIG = "$BAZDIR/bazinga.conf";
my $CSS = "$BAZDIR/style.css";
my $BZG_FILE = "$BAZDIR/bazinga.dat";
my $TMP_LOCATION = "$BAZDIR/temp";
my $TEMPLATEFILE = "$BAZDIR/index.template";
my %CONF_HASH;
my %TAG_HASH;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# %needed_params are the paramaters that should be given in the content files
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

my %needed_params = (
    'articles'   => [qw(author title email website text date time tags)],
    'pages'      => [qw(author title email website text date time)],
);


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BZG_HASH is the mega-hash containing all the information.
# if the file is too small (<5b) we can surely asume it doesn't exist,
# otherwise we read in the hash from the file
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

my $BZG_HASH;
if (-e $BZG_FILE && (stat $BZG_FILE)[7] > 5) {
    $BZG_HASH = retrieve $BZG_FILE;
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# here we parse the config file in the users home directory and fill %CONF_HASH
# with all the information.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

open my $CONFFD, "< $CONFIG" or die "can't access config, please check $CONFIG\n";
while (<$CONFFD>) {
    next if m/^#.*/;
    next if m/^[[:space:]]+$/;
    if (m/.*BLOG_DIRECTORY: *\"(.+)\".*/) {
        $CONF_HASH{'blog_directory'} = $1;
        mkdir $CONF_HASH{'blog_directory'} unless -e $CONF_HASH{'blog_directory'};
        mkdir "$CONF_HASH{'blog_directory'}/pages" unless -e "$CONF_HASH{'blog_directory'}/pages";
        mkdir "$CONF_HASH{'blog_directory'}/tags" unless -e "$CONF_HASH{'blog_directory'}/tags";
        mkdir "$CONF_HASH{'blog_directory'}/articles" unless -e "$CONF_HASH{'blog_directory'}/articles";
        mkdir "$CONF_HASH{'blog_directory'}/css" unless -e "$CONF_HASH{'blog_directory'}/css";
    }
    $CONF_HASH{'blog_title'} = $1 if m/.*BLOG_TITLE: *\"(.+)\".*/;
    $CONF_HASH{'blog_subtitle'} = $1 if m/.*BLOG_SUBTITLE: *\"(.+)\".*/;
    $CONF_HASH{'blog_owner'} = $1 if m/.*BLOG_OWNER: *\"(.+)\".*/;
    $CONF_HASH{'blog_email'} = $1 if m/.*BLOG_EMAIL: *\"(.+)\".*/;
    $CONF_HASH{'blog_website'} = $1 if m/.*BLOG_WEBSITE: *\"(.+)\".*/;
    $CONF_HASH{'latex_fgcolor'} = $1 if m/.*LATEX_FGCOLOR: *\"(.+)\".*/;
    $CONF_HASH{'latex_bgcolor'} = $1 if m/.*LATEX_BGCOLOR: *\"(.+)\".*/;
    $CONF_HASH{'latex_dpi'} = $1 if m/.*LATEX_DPI: *\"(.+)\".*/;
    $CONF_HASH{'push_host'} = $1 if m/.*PUSH_HOST: *\"(.+)\".*/;
    $CONF_HASH{'push_login'} = $1 if m/.*PUSH_LOGIN: *\"(.+)\".*/;
    $CONF_HASH{'push_path'} = $1 if m/.*PUSH_PATH: *\"(.+)\".*/;
}
close $CONFFD;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# param check, we die if there is the wrong count
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

die " !! Not enough parameters given, try 'bzg help' for a quick overview.\n" if scalar @ARGV < 1;
die " !! Configuration file $CONFIG doesn't exist or isn't readable, please check.\n" unless (-e $CONFIG);
die " !! Index template $TEMPLATEFILE doesn't exist or isn't readable, please check.\n" unless (-e $TEMPLATEFILE);
mkdir $TMP_LOCATION unless -d $TMP_LOCATION;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# arg-list processing
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

if ($ARGV[0]) {
    if ($ARGV[0] eq "help") {
        print_usage() and exit 0;
    }
    elsif ($ARGV[0] eq "list") {
        list_contents() and exit 0;
    }
    elsif ($ARGV[0] eq "generate") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/(page|article){1}/) {
                make_template($1);
            }
            else {
                print " !! Second argument must be 'article' or 'page'.\n";
            }
        }
    }
    elsif ($ARGV[0] eq "add") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(1, $ARGV[1]);
            }
            else {
                print " !! $ARGV[1] is not a file, please specify a path to a valid content file.\n"; 
            }
        }
        else {
            print " !! You have to specify the path to a valid content file.\n";
            exit 2;
        }
    }
    elsif ($ARGV[0] eq "reset") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{1,32}/) {
                git_reset($ARGV[1]);
            }
            else { 
                print " !! $ARGV[1] is not a valid git-hash, please specify a correct hash.\n"; 
            }
        }
        else {
            print " !! You have to specify a valid git-hash, see 'bzg history'.\n";
            exit 6;
        }
    }
    elsif ($ARGV[0] eq "delete") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{1,16}/) {
                delete_content($ARGV[1]);
            }
            else { 
                print " !! $ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print " !! You have to specify a valid content id.\n";
            exit 3;
        }
    }
    elsif ($ARGV[0] eq "export") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{1,16}/) {
                export_content($ARGV[1]);
            }
            else { 
                print " !! $ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print " !! You have to specify a valid content id.\n";
            exit 3;
        }
    }
    elsif ($ARGV[0] eq "replace") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{1,16}/) {
                if ($ARGV[2]) {
                    if (-e $ARGV[2]) {
                        replace_content($ARGV[1], $ARGV[2]);
                    }
                    else { 
                        print " !! $ARGV[2] is not a file, please specify a path to the content file.\n";
                    }
                }
                else {
                    print " !! You have to specify a valid content file\n";
                    exit 4;
                }
            }
            else { 
                print " !! $ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print " !! You have to specify the id you want to be replaced.\n";
            exit 5;
        }
    }
    elsif ($ARGV[0] eq "check") {
        if ($ARGV[1]) {
            if (-e $ARGV[1]) {
                add_content(0, $ARGV[1]);
            }
            else { 
                print " !! $ARGV[1] is not a file, please specify a path to the article or comment file.\n"; 
            }
        }
        else {
            print " !! You have to specify the path to the content file which should be checked.\n";
            exit 6;
        }
    }
    elsif ($ARGV[0] eq "update") {
        update_bazinga();
    }
    elsif ($ARGV[0] eq "push") {
        push_bazinga();
    }
    elsif ($ARGV[0] eq "history") {
        show_history();
    }
    elsif ($ARGV[0] eq "tag") {
        if ($ARGV[1]) {
            if ($ARGV[1] =~ m/[[:alnum:]]{1,16}/) {
                if ($ARGV[2]) {
                    tag_article($ARGV[1], $ARGV[2]);
                }
                else { 
                   print " !! Please specify one or more tags.\n";
                   exit 4;
                }
            }
            else { 
                print " !! $ARGV[1] is not a valid id, please specify a correct id.\n"; 
            }
        }
        else {
            print " !! You have to specify the id you want to be re-tagged.\n";
            exit 5;
        }
    }
    else { 
        print " !! You entered an unknown parameter, please check.\n"; 
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: reset_git
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  does a git reset --hard
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub git_reset {
    my $githash = shift;
    print " !! Please keep in mind, that a reset is permanent and can't be undone. You have been warned...\n";
    print " >> Do you really want to reset the state to this mark: $githash ? (Y/N)\n";
    print " << ";
    chomp (my $answer = <STDIN>);
    if ($answer eq 'Y') {
        print " >> resetting state\n";
        `cd $BAZDIR; git reset --hard $githash`;
        print " >> done!\n";
    }
    else {
        exit(0);
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: show_history
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  shows a pretty oneline from git
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub show_history {
    my @cmd_ret = `cd $BAZDIR; git log --oneline -n50 2> /dev/null`;
    print "bazinga history (showing 50 latest changes):\n\n";
    exit unless scalar @cmd_ret;
    for (@cmd_ret) {
        print " >> $_";
    }
    print "\n";
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: update_git
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  updates git in $BAZDIR
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub update_git {
    my ($title, $action) = @_;
    if (-d "$BAZDIR/.git") {
        my $date = localtime; 
        `cd $BAZDIR; git add bazinga.dat; git commit -m '$date - $action - $title'`;
    }
    else {
        my $ret = `cd $BAZDIR; git init`;
        open my $GITFD, ">> $BAZDIR/.git/config" or die " !! error $!";
        print $GITFD "\n[user]\n\tname = bazinga\n";
        close $GITFD;
        open my $IGFD, "> $BAZDIR/.gitignore" or die " !! error $!";
        print $IGFD "*.*\n!bazinga.dat\n";
        close $IGFD;
        update_git($title, $action);
    }
}



# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: create_feed
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  updates the rss feed
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub create_feed {
    my $feedfile = $CONF_HASH{'blog_directory'} . "/feed.xml";
    open my $FEEDFD, "> $feedfile" or die " >> Can't open $feedfile: $!\n";
    print $FEEDFD "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" .
                  "<rss version=\"2.0\">\n" .
                  "<channel>\n";
    print $FEEDFD "<title>" . $CONF_HASH{'blog_title'} . "</title>\n";
    print $FEEDFD "<link>" . $CONF_HASH{'blog_website'} . "</link>\n";
    print $FEEDFD "<description>" . $CONF_HASH{'blog_subtitle'} . "</description>\n";
    print $FEEDFD "<language>en</language>\n";
    print $FEEDFD "<copyright>" . $CONF_HASH{'blog_owner'} . "</copyright>\n";
    for (keys %{$BZG_HASH->{'articles'}}) {
        print $FEEDFD "<item>\n";
        print $FEEDFD "<title>" . $BZG_HASH->{'articles'}{$_}{'title'} . "</title>\n";
        my ($year, $month, $day) = split (/-/, $BZG_HASH->{'articles'}{$_}{'date'});
        my $link = $BZG_HASH->{'articles'}{$_}{'title'};
        $link =~ s/ +/-/g;
        $link =~ s/[^a-z0-9A-Z-]//g;
        $link = lc(substr($link, 0, 30));
        print $FEEDFD "<link>" .  $CONF_HASH{'blog_website'} . "/articles/$year/$month/$day/$link.html</link>\n";
        print $FEEDFD "<author>" . $BZG_HASH->{'articles'}{$_}{'author'} . "</author>\n";
        print $FEEDFD "<guid>" .  $CONF_HASH{'blog_website'} . "/articles/$year/$month/$day/$link.html</guid>\n";
        print $FEEDFD "</item>\n";
    }
    print $FEEDFD "</channel>\n";
    print $FEEDFD "</rss>\n";
    close $FEEDFD;
}




# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: push_bazinga
# needs:    ncftp
# returns:  nothing
# calls:    ncftp (system)
# purpose:  updates the ftp structure
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub push_bazinga {
    die " !! Please specify PUSH_HOST in config first!\n" unless $CONF_HASH{'push_host'};
    die " !! Please specify PUSH_LOGIN in config first!\n" unless $CONF_HASH{'push_login'};
    die " !! Please specify PUSH_PATH in config first!\n" unless $CONF_HASH{'push_path'};
    print " >> Pushing to: " . $CONF_HASH{'push_host'} . " into directory " .
          $CONF_HASH{'push_path'} . "\n";
    print "Please enter your password (won't be echoed): ";
    system('stty','-echo');
    chop(my $password=<STDIN>);
    system('stty','echo');
    print "\n";
    system("echo 'lcd " . $CONF_HASH{'blog_directory'} . "; cd " . 
            $CONF_HASH{'push_path'} . "; rm -rf articles tags pages css index.html feed.xml' | ncftp -u " .  $CONF_HASH{'push_login'} .
            " -p $password " . $CONF_HASH{'push_host'} . " > /dev/null 2> /dev/null;");
    system("echo 'lcd " . $CONF_HASH{'blog_directory'} . "; cd " . 
            $CONF_HASH{'push_path'} . "; mput -R *' | ncftp -u " .  $CONF_HASH{'push_login'} .
            " -p $password " . $CONF_HASH{'push_host'} . " > /dev/null 2> /dev/null;");
    print " >> Push done!\n";
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: print_usage
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays short usage information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub print_usage {
    print qq(
    bazinga $VERSION

    quick overview:
    
        bzg help
        bzg generate (article | page)
        bzg add FILE
        bzg delete ID
        bzg replace ID FILE
        bzg tag ID "TAG1 TAG2 TAG3 ..."
        bzg check FILE
        bzg list
        bzg export ID
        bzg update 
        bzg history 
        bzg reset GIT-ID 
        bzg push

    examples:

        bzg generate article > my_template_article.txt
        bzg generate page > my_template_page.txt
        bzg export 67fa > backup_page.txt
        bzg add my_fancy_new_article.txt
        bzg add about_me_page.txt
        bzg replace 6783423 corrected_article.txt
        bzg tag 6783423 "main programming testing"
        bzg check maybe_corrupt_article.txt
        bzg update
        bzg push

);
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: list_contents
# needs:    nothing
# returns:  nothing
# calls:    nothing
# purpose:  displays a list of all the contents
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub list_contents {
    print "Articles:\n" . "* " x 20 . "\n";
    for (sort { $BZG_HASH->{'articles'}{$a}{'date'} cmp  $BZG_HASH->{'articles'}{$b}{'date'} } keys %{$BZG_HASH->{'articles'}}) {
        print " $_ ($BZG_HASH->{'articles'}{$_}{'title'})";
        print " from: $BZG_HASH->{'articles'}{$_}{'author'} - $BZG_HASH->{'articles'}{$_}{'date'}";
        print " $BZG_HASH->{'articles'}{$_}{'time'}\n";
    }
    print "\n\n";
    print "Pages:\n" . "* " x 20 . "\n";
    for (sort { $BZG_HASH->{'pages'}{$a}{'title'} cmp $BZG_HASH->{'pages'}{$b}{'title'} } keys %{$BZG_HASH->{'pages'}}) {
        print " $_ ($BZG_HASH->{'pages'}{$_}{'title'})";
        print " from: $BZG_HASH->{'pages'}{$_}{'author'} - $BZG_HASH->{'pages'}{$_}{'date'}";
        print " $BZG_HASH->{'pages'}{$_}{'time'}\n";
    }
    print "\n\n";
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: add_content
# needs:    1 or 0 (only check), path to content file, (maybe ID, only if called from replace_content)
# returns:  nothing
# calls:    nothing
# purpose:  processes the content file and fills the super hash with the content information
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub add_content {
    my ($add, $content_file, $given_id) = @_;
    my ($type, $random);
    if ($given_id) {
        $random = $given_id;
    }
    else {
        $random = join ("", ('a' .. 'f', 0 .. 9)[map {rand (16)} (1 .. 16)] );
    }
    open my $CONTFD ,"< $content_file" or die " !! File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        $BZG_HASH->{$1}{$random} = {} and $type = $1 and last if m/^category: *\"(articles|pages){1}\".*$/;
    }
    close $CONTFD;
    unless ($type) {
        print " !! Content file is missing the 'category' param, please check and re-run.\n";
        exit;
    }
    open $CONTFD ,"< $content_file" or die " !! File could not be opened, please check permissions.\n";
    while (<$CONTFD>) {
        if (/START_TEXT/ .. /END_TEXT/) {
            $BZG_HASH->{$type}{$random}{'text'} .= $_ if $_ !~ /.*(END_TEXT|START_TEXT){1}.*/ ;
        }
        else {
            $BZG_HASH->{$type}{$random}{$1} = $2 and next if m/^(.+): *\"(.+)\".*$/;
        }

    }
    close $CONTFD;
    my $correct = 1;
    for my $list_item (@{$needed_params{$type}}) {
        unless ( grep {/$list_item/} keys %{$BZG_HASH->{$type}{$random}}) {
            print " !! Argument '$list_item' is missing in content-file, exiting.\n";
            $correct = 0;
        }
    }
    if ($correct) {
        print " >> Content file seems to be correct.\n";
    }
    else {
        print " !! Content file is corrupt, please check.\n";
        exit;
    }
    if ($add) {
        update_git($BZG_HASH->{$type}{$random}{'title'}, "added");
        store $BZG_HASH, $BZG_FILE;
        print " >> Added '$random' to $type.\n";
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: export_content
# needs:    valid id from a page / article
# returns:  nothing
# calls:    nothing
# purpose:  exports pages or articlesx
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub export_content {
    my $export_id = shift;
    my $key =  0;
    if (exists $BZG_HASH->{'pages'}) {
        for $key (keys %{$BZG_HASH->{'pages'}}) {
            if ($key =~ m/^$export_id.*/) {
                print "category: \"pages\"\n";
                print "author: \"" . $BZG_HASH->{'pages'}{$key}{'author'} . "\"\n";
                print "website: \"" . $BZG_HASH->{'pages'}{$key}{'website'} . "\"\n";
                print "email: \"" . $BZG_HASH->{'pages'}{$key}{'email'} . "\"\n";
                print "title: \"" . $BZG_HASH->{'pages'}{$key}{'title'} . "\"\n";
                print "date: \"" . $BZG_HASH->{'pages'}{$key}{'date'} . "\"\n";
                print "time: \"" . $BZG_HASH->{'pages'}{$key}{'time'} . "\"\n\n";
                print "START_TEXT\n";
                print $BZG_HASH->{'pages'}{$key}{'text'};
                print "END_TEXT\n";
            }
        }
    }
    if (exists $BZG_HASH->{'articles'}) {
        for $key (keys %{$BZG_HASH->{'articles'}}) {
            if ($key =~ m/^$export_id.*/) {
                print "category: \"articles\"\n";
                print "author: \"" . $BZG_HASH->{'articles'}{$key}{'author'} . "\"\n";
                print "website: \"" . $BZG_HASH->{'articles'}{$key}{'website'} . "\"\n";
                print "email: \"" . $BZG_HASH->{'articles'}{$key}{'email'} . "\"\n";
                print "title: \"" . $BZG_HASH->{'articles'}{$key}{'title'} . "\"\n";
                print "date: \"" . $BZG_HASH->{'articles'}{$key}{'date'} . "\"\n";
                print "time: \"" . $BZG_HASH->{'articles'}{$key}{'time'} . "\"\n";
                print "tags: \"" . $BZG_HASH->{'articles'}{$key}{'tags'} . "\"\n\n";
                print "START_TEXT\n";
                print $BZG_HASH->{'articles'}{$key}{'text'};
                print "END_TEXT\n";
            }
        }
    }
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: delete content
# needs:    valid id from a page / article
# returns:  nothing
# calls:    nothing
# purpose:  deletes any content and the corresponding id from the index
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub delete_content {
    my $delete_id = shift;
    my $key;
    if (exists $BZG_HASH->{'pages'}) {
        for $key (keys %{$BZG_HASH->{'pages'}}) {
            if ($key =~ m/^$delete_id.*/) {
                update_git($BZG_HASH->{'pages'}{$key}{'title'}, "deleted");
                delete $BZG_HASH->{'pages'}{$key};
                print " >> Deleted page '$key'\n";
                store $BZG_HASH, $BZG_FILE;
            }
        }
    }
    if (exists $BZG_HASH->{'articles'}) {
        for $key (keys %{$BZG_HASH->{'articles'}}) {
            if ($key =~ m/^$delete_id.*/) {
                update_git($BZG_HASH->{'articles'}{$key}{'title'}, "deleted");
                delete $BZG_HASH->{'articles'}{$key};
                print " >> Deleted article '$key'\n";
                store $BZG_HASH, $BZG_FILE;
            }
        }
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: tag_article
# needs:    valid id from an article, string with tags
# returns:  nothing
# calls:    nothing
# purpose:  deletes the tags from a given article and adds new ones
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub tag_article {
    my ($tag_id, $tags) = @_;
    my $tag_complete;
    for my $key (keys %{$BZG_HASH->{'articles'}}) {
        if ($key =~ m/^$tag_id.*/) {
            $tag_complete = $key;
        }
    }
    if (exists  $BZG_HASH->{'articles'}{$tag_complete}) {
        $BZG_HASH->{'articles'}{$tag_complete}{'tags'} = $tags;
        print " >> Tagged article '$tag_complete'.\n";
        update_git($BZG_HASH->{'articles'}{$tag_complete}{'title'}, "tagged");
        store $BZG_HASH, $BZG_FILE;
    }
    else {
        print " !! Article $tag_id doesn't exist, please check.\n";
        exit 5;
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: replace_content
# needs:    valid id from a page / article, and path to a new content file
# returns:  nothing
# calls:    add_content, delete_content
# purpose:  deletes any content and the corresponding id from the index and adds a new one
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub replace_content {
    my ($id, $path) = @_;
    my $full_id;
    for (keys %{$BZG_HASH->{'pages'}}) {
        if ($_ =~ m/^$id.*/) {
            $full_id = $_;
        }
    }
    for (keys %{$BZG_HASH->{'articles'}}) {
        if ($_ =~ m/^$id.*/) {
            $full_id = $_;
        }
    }
    delete_content($id);
    if ($full_id) {
        add_content(1, $path, $full_id);
    }
    else {
        print " !! Content with id $id doesn't exist, please check.\n";
        exit 5;
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: update_bazinga
# needs:    nothing
# returns:  nothing
# calls:    generate_file, generate_index
# purpose:  copies an existing css file from the users home dir to the structure or dies if the
#           copy-prrocess fails. after that it loops through the sections and then through the ids
#           and passes them to generate_file for further processing. in the end, the index is
#           (re)generated.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub update_bazinga {
    print " >> Updating local bazinga directory.\n";
    system("rm -rf " . $CONF_HASH{'blog_directory'} . "/*");
    generate_tagpages();
    if (-e $CSS) {
        mkdir($CONF_HASH{'blog_directory'} . "/css");
        copy($CSS, "$CONF_HASH{'blog_directory'}/css/style.css") or die " !! Copy of css failed: $!\n";
    }
    for my $section (keys %{$BZG_HASH}) {
        for (keys %{$BZG_HASH->{$section}}) { 
            generate_file($section, $_);
        }
    }
    generate_index();
    create_feed();
    print " >> Update complete.\n"
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_file
# needs:    category (articles/pages/tags) and the ID (which could be a tagname too)
# returns:  nothing
# calls:    convert_text
# purpose:  uses the index-template to generate a website for an article or a page. additionally,
#           it creates the needed directory-structure. tag-pages were added after initial 
#           implementation, but fit in here quite nicely. :)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_file {
    my ($type, $id) = @_;
    my ($dirstring, $year, $month, $day);
    if ($type ne 'tags') {
        $dirstring = $BZG_HASH->{$type}{$id}{'title'};
        ($year, $month, $day) = split (/-/, $BZG_HASH->{$type}{$id}{'date'});
        $dirstring =~ s/ +/-/g;
        $dirstring =~ s/[^a-z0-9A-Z-]//g;
        $dirstring = lc(substr($dirstring, 0, 30));
    }
    else {
        $dirstring = $id;
        $dirstring = lc(substr($dirstring, 0, 30));
    }
    mkdir ($CONF_HASH{'blog_directory'} . "/$type");
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$year") if $type eq 'articles';
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$year/$month") if $type eq 'articles';
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$year/$month/$day") if $type eq 'articles';
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$year/$month/$day/$dirstring") if $type eq 'articles';
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$year/$month/$day/$dirstring/img") if $type eq "articles";
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$dirstring") if $type eq "pages";
    mkdir ($CONF_HASH{'blog_directory'} . "/$type/$dirstring/img") if $type eq "pages";
    my $indexfile;
    $indexfile = $CONF_HASH{'blog_directory'} . "/$type/$year/$month/$day/$dirstring.html" if $type eq 'articles';;
    $indexfile = $CONF_HASH{'blog_directory'} . "/$type/$dirstring.html" unless $type eq 'articles';
    open my $INDEX, "> $indexfile" or die "$!";
    open my $TEMPLATE, "< $TEMPLATEFILE" or die "$!";
    while (my $line = <$TEMPLATE>) {
        if ($line =~ m/\[BLOG_TITLE\]/gmx) {
            $line =~ s/\[BLOG_TITLE\]/$CONF_HASH{'blog_title'}/gmx;
        }
        if ($line =~ m/\[BLOG_SUBTITLE\]/gmx) {
            $line =~ s/\[BLOG_SUBTITLE\]/$CONF_HASH{'blog_subtitle'}/gmx;
        }
        if ($line =~ m/\[BLOG_WEBSITE\]/gmx) {
            $line =~ s/\[BLOG_WEBSITE\]/$CONF_HASH{'blog_website'}/gmx;
        }
        if ($line =~ m/\[STYLESHEET_LOCATION\]/gmx) {
            $line =~ s/\[STYLESHEET_LOCATION\]/\.\.\/\.\.\/\.\.\/\.\.\/css\/style.css/gmx if $type eq 'articles';
            $line =~ s/\[STYLESHEET_LOCATION\]/\.\.\/css\/style.css/gmx unless $type eq 'articles';
        }
        if ($line =~ m/\[MENU\]/gmx) {
            $line =~ s/\[MENU\]//gmx;
            $line .= "<div class='menupoint'><a href='../../../../index.html'>" .
                     "main page</a></div><br />\n" if $type eq 'articles';
            $line .= "<div class='menupoint'><a href='../index.html'>" .
                     "main page</a></div><br />\n" unless $type eq 'articles';
            for (sort keys %{$BZG_HASH}) {
                $line .= "<div class='menupoint'>$_</div>\n";
                if ($_ eq 'articles') {
                    $line .= "<ul>\n";
                    for my $tags (sort keys %TAG_HASH) {
                        $line .= "<li><a href='../../../../tags/$tags.html'>" if $type eq 'articles';
                        $line .= "<li><a href='../tags/$tags.html'>" unless $type eq 'articles';
                        $line .= $tags . "</a><div style='float: right;'>( " . scalar @{$TAG_HASH{$tags}} . 
                                 " )</div></li>\n";
                    }
                    $line .= "</ul>\n";
                }
                elsif ($_ eq 'pages') {
                    $line .= "<ul>\n";
                    for my $pageid (sort {$BZG_HASH->{'pages'}{$a}{'title'} cmp $BZG_HASH->{'pages'}{$b}{'title'}} 
                                        keys %{$BZG_HASH->{'pages'}}) {
                        my $dirstring = $BZG_HASH->{'pages'}{$pageid}{'title'};
                        $dirstring =~ s/ +/-/g;
                        $dirstring =~ s/[^a-z0-9A-Z-]//g;
                        $dirstring = lc(substr($dirstring, 0, 30));

                        $line .= "<li><a href='../../../../pages/$dirstring.html'>" . 
                                 $BZG_HASH->{'pages'}{$pageid}{'title'} . "</a></li>\n" if $type eq 'articles';
                        $line .= "<li><a href='../pages/$dirstring.html'>" . 
                                 $BZG_HASH->{'pages'}{$pageid}{'title'} . "</a></li>\n" unless $type eq 'articles';
                    
                    }
                    $line .= "</ul>\n";
                }
            }
        }
        if ($line =~ m/\[CONTENT\]/gmx) {
            if ($type ne "tags") {
                $line =~ s/\[CONTENT\]//gmx;
                $line .= "<h2>$BZG_HASH->{$type}{$id}{'title'}</h2>";
                $line .= convert_text($BZG_HASH->{$type}{$id}{'text'}, $id);
            }
            else {
                $line =~ s/\[CONTENT\]//gmx;
                $line .= "<h2>Articles with tag: $id</h2>";
                for (@{$TAG_HASH{$id}}) {
                    my $dirstring = $BZG_HASH->{'articles'}{$_}{'title'};
                    ($year, $month, $day) = split (/-/, $BZG_HASH->{'articles'}{$_}{'date'});
                    $dirstring =~ s/ +/-/g;
                    $dirstring =~ s/[^a-z0-9A-Z-]//g;
                    $dirstring = lc(substr($dirstring, 0, 30));
                    $line .= "<p>(" . $BZG_HASH->{'articles'}{$_}{'date'} . 
                             " - " . $BZG_HASH->{'articles'}{$_}{'time'} . 
                             ") : <a href='../../../../articles/$year/$month/$day/$dirstring.html'>" . 
                             $BZG_HASH->{'articles'}{$_}{'title'} .
                             "</a></p>" if $line eq 'articles';
                    $line .= "<p>(" . $BZG_HASH->{'articles'}{$_}{'date'} . 
                             " - " . $BZG_HASH->{'articles'}{$_}{'time'} . 
                             ") : <a href='../articles/$year/$month/$day/$dirstring.html'>" . 
                             $BZG_HASH->{'articles'}{$_}{'title'} .
                             "</a></p>" unless $line eq 'articles';
                }
            }
            if ($type eq 'articles') {
            $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{$type}{$id}{'author'} . 
                     " in " . join(", ", split / /, $BZG_HASH->{$type}{$id}{'tags'}) . " on <i>" .
                     $BZG_HASH->{$type}{$id}{'date'} . " " . $BZG_HASH->{$type}{$id}{'time'} .
                     "</i></div>";
            }
            elsif ($type eq 'pages') {
            $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{$type}{$id}{'author'} . 
                     " on <i>" .
                     $BZG_HASH->{$type}{$id}{'date'} . " " . $BZG_HASH->{$type}{$id}{'time'} .
                     "</i></div>";
            }
        }

        print $INDEX $line;
    }
    close $INDEX;
    close $TEMPLATE;
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_index
# needs:    nothing
# returns:  nothing
# calls:    convert_text
# purpose:  uses the index-template to generate the main index page.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_index {
    my $indexfile = $CONF_HASH{'blog_directory'} . "/index.html";
    open my $INDEX, "> $indexfile" or die "$!";
    open my $TEMPLATE, "< $TEMPLATEFILE" or die "$!";
    my %date_hash;
    while (my $line = <$TEMPLATE>) {
        if ($line =~ m/\[BLOG_TITLE\]/gmx) {
            $line =~ s/\[BLOG_TITLE\]/$CONF_HASH{'blog_title'}/gmx;
        }
        if ($line =~ m/\[BLOG_SUBTITLE\]/gmx) {
            $line =~ s/\[BLOG_SUBTITLE\]/$CONF_HASH{'blog_subtitle'}/gmx;
        }
        if ($line =~ m/\[BLOG_WEBSITE\]/gmx) {
            $line =~ s/\[BLOG_WEBSITE\]/$CONF_HASH{'blog_website'}/gmx;
        }
        if ($line =~ m/\[STYLESHEET_LOCATION\]/gmx) {
            $line =~ s/\[STYLESHEET_LOCATION\]/\.\/css\/style.css/gmx;
        }
        if ($line =~ m/\[MENU\]/gmx) {
            $line =~ s/\[MENU\]//gmx;
            $line .= "<div class='menupoint'><a href='./index.html'>" .
                     "main page</a></div><br />\n";
            for (sort keys %{$BZG_HASH}) {
                $line .= "<div class='menupoint'>$_</div>\n";
                if ($_ eq 'articles') {
                    $line .= "<ul>\n";
                    for my $tags (sort keys %TAG_HASH) {
                        $line .= "<li><a href='./tags/$tags.html'>" .
                                 $tags . "</a><div style='float: right;'>( " . scalar @{$TAG_HASH{$tags}} . 
                                 " )</div></li>\n";
                    }
                    $line .= "</ul>\n";
                }
                elsif ($_ eq 'pages') {
                    $line .= "<ul>\n";
                    for my $pageid (sort {$BZG_HASH->{'pages'}{$a}{'title'} cmp $BZG_HASH->{'pages'}{$b}{'title'}} 
                                        keys %{$BZG_HASH->{'pages'}}) {
                        my $dirstring = $BZG_HASH->{'pages'}{$pageid}{'title'};
                        $dirstring =~ s/ +/-/g;
                        $dirstring =~ s/[^a-z0-9A-Z-]//g;
                        $dirstring = lc(substr($dirstring, 0, 30));

                        $line .= "<li><a href='./pages/$dirstring.html'>" . 
                                 $BZG_HASH->{'pages'}{$pageid}{'title'} . "</a></li>\n";
                    
                    }
                    $line .= "</ul>\n";
                }
            }
        }
        if ($line =~ m/\[CONTENT\]/gmx) {
            $line =~ s/\[CONTENT\]//gmx;
            for (keys %{$BZG_HASH->{'articles'}}) {
                push @{$date_hash{$BZG_HASH->{'articles'}{$_}{'date'} . " " . $BZG_HASH->{'articles'}{$_}{'time'}}}, $_;
            }
            for (reverse sort keys %date_hash) {
                for my $id (@{$date_hash{$_}}) {
                    my $dirstring = $BZG_HASH->{'articles'}{$id}{'title'};
                    my ($year, $month, $day) = split (/-/, $BZG_HASH->{'articles'}{$id}{'date'});
                    $dirstring =~ s/ +/-/g;
                    $dirstring =~ s/[^a-z0-9A-Z-]//g;
                    $dirstring = lc(substr($dirstring, 0, 30));
                    $line .= "<h2><a href='./articles/$year/$month/$day/$dirstring.html'>$BZG_HASH->{'articles'}{$id}{'title'}</a></h2>";
                    $line .= convert_text($BZG_HASH->{'articles'}{$id}{'text'}, $id, "index");
                    $line .= "<div class='b_art_info'>posted by " . $BZG_HASH->{'articles'}{$id}{'author'} . 
                             " in " . join(", ", split / /, $BZG_HASH->{'articles'}{$id}{'tags'}) . " on <i>" .
                             $BZG_HASH->{'articles'}{$id}{'date'} . " " . $BZG_HASH->{'articles'}{$id}{'time'} .
                             "</i></div>";
                }
            }
        }

        print $INDEX $line;
    }
    close $INDEX;
    close $TEMPLATE;
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: generate_tagpages
# needs:    nothing
# returns:  nothing
# calls:    generate_file
# purpose:  goes through the content-hash and generates the corresponding pages
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub generate_tagpages {
    for my $artid (keys %{$BZG_HASH->{'articles'}}) {
        for (split / /, $BZG_HASH->{'articles'}{$artid}{'tags'}) {
            push @{$TAG_HASH{$_}}, $artid;
        }
    }
    system("rm -rf " .  $CONF_HASH{'blog_directory'} . "/tags/ 2> /dev/null");
    for (keys %TAG_HASH) {
        mkdir $CONF_HASH{'blog_directory'} . "/tags/" 
        unless -d $CONF_HASH{'blog_directory'} . "/tags/";
        mkdir $CONF_HASH{'blog_directory'} . "/tags/$_" 
        unless -d $CONF_HASH{'blog_directory'} . "/tags/$_";
        generate_file("tags", $_);
    }
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: convert_text
# needs:    scalar textstring from generate_file, article-id, ("index")
# returns:  processed scalar textstring
# calls:    systemcalls: texi2dvi, dvipng
# purpose:  converts the string between START_TEXT and END_TEXT from the content file into desired
#           format. converts latex-formulae into pictures, hihjlights the code, and so on.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub convert_text {
    my ($text, $art_id, $is_index) = @_;
    my ($code_text, $code_lang, $want_ln, $line_number, $in_code, $in_latex, $in_gnuplot, $latex_present, $gnuplot_present) = 
       (0, 0, 0, 0, 0, 0, 0, 0, 0);
    $text =~ s/\r//gmx;
    my ($LATEXFD, $GNUPLOTFD, $IMAGEFD);
    my @textlines = split /\n/, $text;
    my $finaltext;
    my $dirstring;
    my ($year, $month, $day);
    my $is_page = 0;
    if (exists $BZG_HASH->{'articles'}{$art_id}) {
        $dirstring = $BZG_HASH->{'articles'}{$art_id}{'title'};
        ($year, $month, $day) = split (/-/, $BZG_HASH->{'articles'}{$art_id}{'date'});
        $dirstring =~ s/ +/-/g;
        $dirstring =~ s/[^a-z0-9A-Z-]//g;
        $dirstring = lc(substr($dirstring, 0, 30));
    }
    else {
        $dirstring = $BZG_HASH->{'pages'}{$art_id}{'title'};
        $dirstring =~ s/ +/-/g;
        $dirstring =~ s/[^a-z0-9A-Z-]//g;
        $dirstring = lc(substr($dirstring, 0, 30));
        $is_page = 1;
    }

    for (@textlines) {
        if (m/LATEX_START/) {
            $latex_present++;
            $in_latex = 1;
            open $LATEXFD, "> $TMP_LOCATION/$latex_present-pre.tex";
            print $LATEXFD "\\documentclass{article}\n" .  "\\pagestyle{empty}\n" . "\\begin{document}\n";
            if ($is_index) {
                $finaltext .= "<br /><img src='./articles/$year/$month/$day/$dirstring/img/$latex_present-latex.png' alt='$latex_present' /><br />\n" unless $is_page;
            }
            else {
                $finaltext .= "<br /><img src='./$dirstring/img/$latex_present-latex.png' alt='$latex_present' /><br />\n";
            }

            next;
        }
        if (m/LATEX_END/) {
            $in_latex = 0;
            print $LATEXFD "\\end{document}\n";
            close $LATEXFD;
            next;
        }
        if (m/GNUPLOT_START/) {
            $gnuplot_present++;
            $in_gnuplot = 1;
            open $GNUPLOTFD, "> $TMP_LOCATION/$gnuplot_present-gnu.plot";
            print $GNUPLOTFD "set terminal png\n" . "set output '$gnuplot_present-gnu.png'\n";
            if ($is_index) {
                $finaltext .= "<br /><img src='./articles/$year/$month/$day/$dirstring/img/$gnuplot_present-gnu.png' alt='$gnuplot_present' /><br />\n" unless $is_page;
            }
            else {
                $finaltext .= "<br /><img src='./$dirstring/img/$gnuplot_present-gnu.png' alt='$gnuplot_present' /><br />\n";
            }
            next;
        }
        if (m/GNUPLOT_END/) {
            $in_gnuplot = 0;
            close $GNUPLOTFD;
            next;
        }
        if (m/CODE_START=([[:alnum:]]+)=?(ln|LN)?/) {
            ($in_code, $line_number) = (1, 1);
            $code_lang = lc $1;
            if (defined $2 and $2 =~ m/ln|LN/) {
                $want_ln = 1;
            }
            else {
                $want_ln = 0;
            }
            $finaltext .= "<pre class='sourcecode'>\n";
            next;
        }
        if (m/CODE_END/) {
            $in_code = 0;
            $finaltext .= "</pre>\n";
            next;
        }

        if ($in_latex) {
            print $LATEXFD $_ . "\n";
        }
        elsif ($in_code) {
            $_ =~ s/'/´/gmx;
            $finaltext .= `echo '$_' | highlight -s 'vampire' -I -f -l -m $line_number --inline-css -S $code_lang` if $want_ln;
            $finaltext .= `echo '$_' | highlight -s 'vampire' -I -f --inline-css -S $code_lang` unless $want_ln;
            $line_number++;
        }
        elsif ($in_gnuplot) {
            print $GNUPLOTFD $_ . "\n";
        }
        else {
            $finaltext .= $_;
        }
    }
    for (1 .. $latex_present) {
        system("cd $TMP_LOCATION; latex -interaction=batchmode  $_-pre.tex > /dev/null");
        system("cd $TMP_LOCATION; dvipng '$_-pre.dvi' -bg '" . $CONF_HASH{'latex_bgcolor'} . 
               "' -D '" . $CONF_HASH{'latex_dpi'} . "' -fg '" . $CONF_HASH{'latex_fgcolor'} . 
               "' -T tight -o '" . $CONF_HASH{'blog_directory'} . 
               "/articles/$year/$month/$day/$dirstring/img/$_-latex.png' 1> /dev/null 2> /dev/null") unless $is_page;
        system("cd $TMP_LOCATION; dvipng '$_-pre.dvi' -bg '" . $CONF_HASH{'latex_bgcolor'} . 
               "' -D '" . $CONF_HASH{'latex_dpi'} . "' -fg '" . $CONF_HASH{'latex_fgcolor'} . 
               "' -T tight -o '" . $CONF_HASH{'blog_directory'} . 
               "/pages/$dirstring/img/$_-latex.png' 1> /dev/null 2> /dev/null") if $is_page;

        unlink("$TMP_LOCATION/$_-pre.tex", "$TMP_LOCATION/$_-pre.aux", "$TMP_LOCATION/$_-pre.dvi", "$TMP_LOCATION/$_-pre.log");
    }
    for (1 .. $gnuplot_present) {
        system("cd $TMP_LOCATION; gnuplot $_-gnu.plot 1> /dev/null 2> /dev/null");
        system("convert -scale '400x300' '$TMP_LOCATION/$_-gnu.png' '" . $CONF_HASH{'blog_directory'} . 
               "/articles/$year/$month/$day/$dirstring/img/$_-gnu.png' 1> /dev/null 2> /dev/null") unless $is_page;
        system("convert -scale '400x300' '$TMP_LOCATION/$_-gnu.png' '" . $CONF_HASH{'blog_directory'} . 
               "/pages/$dirstring/img/$_-gnu.png' 1> /dev/null 2> /dev/null") if $is_page;
        unlink("$TMP_LOCATION/$_-gnu.plot", "$TMP_LOCATION/$_-gnu.png");
    }

    return $finaltext;
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# function: make_template 
# needs:    category (article/comment/page)
# returns:  doesn't return anything, but prints a template content file to STDOUT
# calls:    nothing
# purpose:  creates a template for an article, comment or page which the user can then pipe into 
#           a file and change the values to his needs.
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub make_template {
    my $type = shift;
    $type = "articles" if $type eq "article";
    $type = "pages" if $type eq "page";
    my $date = sprintf("%d-%02d-%02d", (localtime)[5] + 1900, (localtime)[4] + 1, (localtime)[3]);
    my $time = sprintf("%02d:%02d", (localtime)[2], (localtime)[1]);
    $CONF_HASH{'blog_owner'} = $USERNAME unless $CONF_HASH{'blog_owner'};
    if ($type eq 'articles') {
        print <<"EOTEMP";
category: "$type"
title: ""
author: "$CONF_HASH{"blog_owner"}"
website: "$CONF_HASH{"blog_website"}"
email: "$CONF_HASH{"blog_email"}"
date: "$date"
time: "$time"
tags: ""
START_TEXT

END_TEXT

EOTEMP
    }
    elsif ($type eq "pages") {
        print <<"EOTEMP";
category: "$type"
title: ""
author: "$CONF_HASH{"blog_owner"}"
website: "$CONF_HASH{"blog_website"}"
email: "$CONF_HASH{"blog_email"}"
date: "$date"
time: "$time"
START_TEXT

END_TEXT

EOTEMP
    }
}
